#!/usr/bin/env python3
# -*- coding: utf-8 -*-
# Generated start script for CLS Java application
# Python 3.6 compatible lifecycle management

import os
import sys
import subprocess
import time
import signal
import glob
import shutil
from datetime import datetime

# Try to import fcntl (not available on all systems)
try:
    import fcntl
    HAS_FCNTL = True
except ImportError:
    HAS_FCNTL = False

INSTANCE_DIR = "{{ instance_dir }}"
RELEASE_DIR = os.path.join(INSTANCE_DIR, "current")
RUN_DIR = os.path.join(RELEASE_DIR, "run")
SCRIPTS_DIR = os.path.join(RELEASE_DIR, "scripts")
LOG_DIR = os.path.join(INSTANCE_DIR, "log")
STARTUP_LOG = os.path.join(LOG_DIR, "startup.log")
PID_FILE = os.path.join(RUN_DIR, "app.pid")
LOCK_FILE = os.path.join(RUN_DIR, "start.lock")
STATE_ENV = os.path.join(RUN_DIR, "state.env")
JVM_ARGS_FILE = os.path.join(RUN_DIR, "jvm.args")

# CLS directory - files from dist/cls/ in repo end up here in distribution
CLS_DIR = os.path.join(RELEASE_DIR, "cls")
HOOKS_DIR = os.path.join(CLS_DIR, "hooks.d")

# Configuration
STARTUP_TIMEOUT = 300  # 5 minutes total startup timeout
STABILITY_CHECKS = 5
STABILITY_INTERVAL = 2  # seconds
MAX_STARTUP_LOG_SIZE = 10 * 1024 * 1024  # 10MB
STARTUP_LOG_BACKUPS = 5

# Hook scripts
PRE_START_HOOK = os.path.join(HOOKS_DIR, "pre-start.sh") if os.path.exists(HOOKS_DIR) else None
POST_START_HOOK = os.path.join(HOOKS_DIR, "post-start.sh") if os.path.exists(HOOKS_DIR) else None

# Ensure directories exist
os.makedirs(LOG_DIR, exist_ok=True)
os.makedirs(RUN_DIR, exist_ok=True)

# Global variables for cleanup
lock_fd = None
process = None
start_time = time.time()

def cleanup_on_exit(signum, frame):
    """Handle signals gracefully"""
    log_message("Received signal {}, cleaning up...".format(signum))
    if process and process.poll() is None:
        try:
            process.terminate()
            process.wait(timeout=5)
        except:
            try:
                process.kill()
            except:
                pass
    if lock_fd:
        try:
            fcntl.flock(lock_fd, fcntl.LOCK_UN)
            os.close(lock_fd)
        except:
            pass
    if os.path.exists(LOCK_FILE):
        try:
            os.remove(LOCK_FILE)
        except:
            pass
    sys.exit(1)

# Register signal handlers
signal.signal(signal.SIGINT, cleanup_on_exit)
signal.signal(signal.SIGTERM, cleanup_on_exit)

def log_message(message):
    """Log message to both stdout and startup.log"""
    timestamp = datetime.now().strftime("%Y-%m-%d %H:%M:%S")
    log_line = "[{}] {}".format(timestamp, message)
    print(log_line)
    try:
        # Rotate log if too large
        if os.path.exists(STARTUP_LOG) and os.path.getsize(STARTUP_LOG) > MAX_STARTUP_LOG_SIZE:
            rotate_startup_log()
        
        with open(STARTUP_LOG, 'a') as f:
            f.write(log_line + "\n")
    except IOError as e:
        print("Warning: Could not write to startup.log: {}".format(e))

def rotate_startup_log():
    """Rotate startup log file"""
    try:
        # Remove oldest backup
        oldest = "{}.{}".format(STARTUP_LOG, STARTUP_LOG_BACKUPS)
        if os.path.exists(oldest):
            os.remove(oldest)
        
        # Rotate existing backups
        for i in range(STARTUP_LOG_BACKUPS - 1, 0, -1):
            old = "{}.{}".format(STARTUP_LOG, i)
            new = "{}.{}".format(STARTUP_LOG, i + 1)
            if os.path.exists(old):
                if os.path.exists(new):
                    os.remove(new)
                shutil.move(old, new)
        
        # Move current log to .1
        if os.path.exists(STARTUP_LOG):
            shutil.move(STARTUP_LOG, "{}.1".format(STARTUP_LOG))
    except Exception as e:
        print("Warning: Could not rotate startup log: {}".format(e))

def acquire_lock():
    """Acquire lock file to prevent concurrent starts"""
    global lock_fd
    try:
        if HAS_FCNTL:
            lock_fd = os.open(LOCK_FILE, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)
            fcntl.flock(lock_fd, fcntl.LOCK_EX | fcntl.LOCK_NB)
            # Write PID to lock file
            os.write(lock_fd, str(os.getpid()).encode())
        else:
            # Fallback: check if lock file exists and contains a running PID
            if os.path.exists(LOCK_FILE):
                try:
                    with open(LOCK_FILE, 'r') as f:
                        lock_pid = int(f.read().strip())
                    # Check if that PID is still running
                    try:
                        os.kill(lock_pid, 0)
                        log_message("Error: Lock file exists with running PID {} (another start may be in progress)".format(lock_pid))
                        return False
                    except OSError:
                        # PID doesn't exist, remove stale lock
                        os.remove(LOCK_FILE)
                except (ValueError, IOError):
                    # Invalid lock file, remove it
                    try:
                        os.remove(LOCK_FILE)
                    except:
                        pass
            # Create lock file
            lock_fd = os.open(LOCK_FILE, os.O_CREAT | os.O_WRONLY | os.O_TRUNC)
            os.write(lock_fd, str(os.getpid()).encode())
        return True
    except (IOError, OSError) as e:
        if lock_fd:
            try:
                os.close(lock_fd)
            except:
                pass
        log_message("Error: Could not acquire lock file (another start may be in progress): {}".format(e))
        return False

def release_lock():
    """Release lock file"""
    global lock_fd
    if lock_fd:
        try:
            if HAS_FCNTL:
                fcntl.flock(lock_fd, fcntl.LOCK_UN)
            os.close(lock_fd)
            lock_fd = None
        except:
            pass
    if os.path.exists(LOCK_FILE):
        try:
            os.remove(LOCK_FILE)
        except:
            pass

def check_disk_space(path, min_free_mb=100):
    """Check if there's enough disk space"""
    try:
        stat = os.statvfs(path)
        free_mb = (stat.f_bavail * stat.f_frsize) / (1024 * 1024)
        if free_mb < min_free_mb:
            log_message("Warning: Low disk space: {:.1f}MB free (minimum: {}MB)".format(free_mb, min_free_mb))
            return False
        return True
    except Exception as e:
        log_message("Warning: Could not check disk space: {}".format(e))
        return True  # Don't fail on check errors

def verify_java_version(java_cmd):
    """Verify Java version"""
    try:
        result = subprocess.run(
            [java_cmd, "-version"],
            stdout=subprocess.PIPE,
            stderr=subprocess.STDOUT,
            universal_newlines=True,
            timeout=10
        )
        version_output = result.stdout or result.stderr or ""
        log_message("Java version: {}".format(version_output.split('\n')[0] if version_output else "unknown"))
        return True
    except Exception as e:
        log_message("Warning: Could not verify Java version: {}".format(e))
        return True  # Don't fail on version check

def verify_process_ownership(pid, expected_cmd_pattern):
    """Verify that PID belongs to our Java process"""
    try:
        # Read /proc/PID/cmdline (Linux) or use ps (other Unix)
        if os.path.exists("/proc/{}/cmdline".format(pid)):
            with open("/proc/{}/cmdline".format(pid), 'r') as f:
                cmdline = f.read().replace('\0', ' ')
                if expected_cmd_pattern in cmdline:
                    return True
        else:
            # Fallback: use ps command
            result = subprocess.run(
                ["ps", "-p", str(pid), "-o", "command="],
                stdout=subprocess.PIPE,
                stderr=subprocess.PIPE,
                universal_newlines=True,
                timeout=5
            )
            if result.returncode == 0 and expected_cmd_pattern in result.stdout:
                return True
        log_message("Warning: PID {} does not match expected process".format(pid))
        return False
    except Exception as e:
        log_message("Warning: Could not verify process ownership: {}".format(e))
        return True  # Don't fail on verification errors

def run_hook(hook_path, description):
    """Run a bash hook script if it exists"""
    if hook_path and os.path.exists(hook_path) and os.access(hook_path, os.X_OK):
        log_message("Running {} hook: {}".format(description, hook_path))
        try:
            result = subprocess.run(
                ["bash", hook_path],
                env=os.environ,
                stdout=subprocess.PIPE,
                stderr=subprocess.STDOUT,
                universal_newlines=True,
                timeout=300  # 5 minute timeout for hooks
            )
            if result.returncode != 0:
                log_message("Warning: {} hook exited with code {}".format(description, result.returncode))
                if result.stdout:
                    log_message("Hook output: {}".format(result.stdout[:1000]))  # Limit output
                return False
            return True
        except subprocess.TimeoutExpired:
            log_message("Error: {} hook timed out after 5 minutes".format(description))
            return False
        except Exception as e:
            log_message("Error running {} hook: {}".format(description, e))
            return False
    return True

def check_process_running(pid):
    """Check if a process with given PID is running"""
    try:
        os.kill(pid, 0)
        return True
    except OSError:
        return False

def wait_for_process_stable(pid, max_checks=STABILITY_CHECKS, check_interval=STABILITY_INTERVAL):
    """Wait and verify process stays running for a period"""
    log_message("Verifying process {} is stable...".format(pid))
    for i in range(max_checks):
        time.sleep(check_interval)
        elapsed = time.time() - start_time
        if elapsed > STARTUP_TIMEOUT:
            log_message("Error: Startup timeout exceeded ({} seconds)".format(STARTUP_TIMEOUT))
            return False
        
        if not check_process_running(pid):
            log_message("Process {} exited unexpectedly after {} seconds".format(pid, i * check_interval))
            return False
        log_message("Process {} still running (check {}/{})".format(pid, i + 1, max_checks))
    return True

def read_error_output():
    """Read error output from log file"""
    error_log = os.path.join(LOG_DIR, "app.err")
    try:
        if os.path.exists(error_log):
            with open(error_log, 'r') as f:
                # Read last 2000 characters
                f.seek(max(0, os.path.getsize(error_log) - 2000))
                return f.read()
    except Exception as e:
        log_message("Warning: Could not read error output: {}".format(e))
    return None

log_message("=" * 60)
log_message("Starting CLS application")
log_message("=" * 60)

# Acquire lock to prevent concurrent starts
if not acquire_lock():
    sys.exit(1)

try:
    # Check disk space
    if not check_disk_space(LOG_DIR):
        log_message("Error: Insufficient disk space")
        sys.exit(1)
    
    # Load environment variables from state.env
    if os.path.exists(STATE_ENV):
        log_message("Loading environment variables from {}".format(STATE_ENV))
        try:
            with open(STATE_ENV, 'r') as f:
                env_count = 0
                for line in f:
                    line = line.strip()
                    if line and not line.startswith('#'):
                        if '=' in line:
                            key, value = line.split('=', 1)
                            os.environ[key.strip()] = value.strip()
                            env_count += 1
            log_message("Loaded {} environment variables".format(env_count))
        except IOError as e:
            log_message("Warning: Could not read state.env: {}".format(e))
    else:
        log_message("No state.env file found, skipping environment variable loading")
    
    # Run pre-start hook
    if not run_hook(PRE_START_HOOK, "pre-start"):
        log_message("Pre-start hook failed, aborting start")
        sys.exit(1)
    
    # Check if already running
    if os.path.exists(PID_FILE):
        try:
            with open(PID_FILE, 'r') as f:
                pid = int(f.read().strip())
            # Check if process is still running
            if check_process_running(pid):
                log_message("Application is already running with PID {}".format(pid))
                sys.exit(1)
            else:
                # Process doesn't exist, remove stale PID file
                log_message("Stale PID file found, removing...")
                try:
                    os.remove(PID_FILE)
                except OSError:
                    pass
        except (ValueError, IOError) as e:
            log_message("Warning: Could not read PID file: {}".format(e))
            try:
                os.remove(PID_FILE)
            except OSError:
                pass
    
    # Validate required files
    if not os.path.exists(JVM_ARGS_FILE):
        log_message("Error: JVM args file not found: {}".format(JVM_ARGS_FILE))
        sys.exit(1)
    
    # Read JVM arguments from base jvm.args file
    jvm_args_lines = []
    try:
        if os.path.exists(JVM_ARGS_FILE):
            with open(JVM_ARGS_FILE, 'r') as f:
                jvm_args_lines = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]
            log_message("Loaded {} JVM arguments from {}".format(len(jvm_args_lines), JVM_ARGS_FILE))
    except IOError as e:
        log_message("Error: Could not read JVM args file: {}".format(e))
        sys.exit(1)
    
    # Look for additional .args file in cls/ directory
    if os.path.exists(CLS_DIR):
        try:
            for file in os.listdir(CLS_DIR):
                if file.endswith('.args'):
                    args_file = os.path.join(CLS_DIR, file)
                    log_message("Found additional JVM args file: {}".format(args_file))
                    try:
                        with open(args_file, 'r') as f:
                            additional_args = [line.strip() for line in f if line.strip() and not line.strip().startswith('#')]
                            jvm_args_lines.extend(additional_args)
                            log_message("Added {} additional JVM arguments".format(len(additional_args)))
                    except IOError as e:
                        log_message("Warning: Could not read additional args file {}: {}".format(args_file, e))
        except OSError as e:
            log_message("Warning: Could not list cls directory: {}".format(e))
    
    jvm_args = ' '.join(jvm_args_lines)
    
    # Set Java home
    java_home = "{{ neuron_cls_java.java_home }}"
    if not os.path.exists(java_home):
        log_message("Error: Java home directory does not exist: {}".format(java_home))
        sys.exit(1)
    
    java_cmd = os.path.join(java_home, "bin", "java")
    if not os.path.exists(java_cmd):
        log_message("Error: Java executable not found: {}".format(java_cmd))
        sys.exit(1)
    
    # Verify Java version
    verify_java_version(java_cmd)
    
    os.environ['JAVA_HOME'] = java_home
    os.environ['PATH'] = os.path.join(java_home, 'bin') + os.pathsep + os.environ.get('PATH', '')
    log_message("Using Java: {}".format(java_cmd))
    
    # Build classpath - collect all JAR files from lib directory
    lib_dir = os.path.join(RELEASE_DIR, "lib")
    classpath_parts = []
    if os.path.exists(lib_dir):
        try:
            # Collect all .jar files
            jar_files = glob.glob(os.path.join(lib_dir, "*.jar"))
            if jar_files:
                classpath_parts.extend(sorted(jar_files))
                log_message("Found {} JAR files in lib directory".format(len(jar_files)))
            # Also check for any additional classpath entries (e.g., classes directory)
            classes_dir = os.path.join(RELEASE_DIR, "classes")
            if os.path.exists(classes_dir):
                classpath_parts.append(classes_dir)
                log_message("Added classes directory to classpath")
            
            if classpath_parts:
                # Use colon separator for classpath (or semicolon on Windows, but we're on Unix)
                classpath = os.pathsep.join(classpath_parts)
            else:
                # Fallback to wildcard if no jars found
                classpath = os.path.join(lib_dir, "*")
                log_message("Warning: No JAR files found, using wildcard classpath")
        except Exception as e:
            log_message("Error building classpath: {}".format(e))
            sys.exit(1)
    else:
        log_message("Warning: lib directory does not exist: {}".format(lib_dir))
        classpath = lib_dir
    
    # Main class
    main_class = "{{ neuron_cls_java.main_class }}"
    if not main_class:
        log_message("Error: main_class is not defined")
        sys.exit(1)
    
    # Param class (optional)
    {% if neuron_cls_java.param_class is defined and neuron_cls_java.param_class %}
    param_class = "{{ neuron_cls_java.param_class }}"
    {% else %}
    param_class = None
    {% endif %}
    
    # Build command
    cmd = [java_cmd] + jvm_args.split() + ["-cp", classpath, main_class]
    {% if neuron_cls_java.param_class is defined and neuron_cls_java.param_class %}
    if param_class:
        cmd.append(param_class)
    {% endif %}
    
    # Start application
    log_message("Starting application...")
    log_message("Command: {}".format(" ".join(cmd)))
    log_message("Classpath: {} ({} entries)".format(
        classpath[:200] + "..." if len(classpath) > 200 else classpath,
        len(classpath_parts) if classpath_parts else 0
    ))
    
    # Open log files
    try:
        stdout_file = open(os.path.join(LOG_DIR, "app.out"), "a")
        stderr_file = open(os.path.join(LOG_DIR, "app.err"), "a")
    except IOError as e:
        log_message("Error: Could not open log files: {}".format(e))
        sys.exit(1)
    
    process = None
    try:
        process = subprocess.Popen(
            cmd,
            stdout=stdout_file,
            stderr=stderr_file,
            env=os.environ,
            preexec_fn=os.setsid
        )
        
        log_message("Process started with PID {}".format(process.pid))
        
        # Save PID to run/ directory
        try:
            with open(PID_FILE, 'w') as f:
                f.write(str(process.pid))
            log_message("PID saved to {}".format(PID_FILE))
        except IOError as e:
            log_message("Error: Could not write PID file: {}".format(e))
            # Try to kill the process if we can't save PID
            try:
                os.killpg(os.getpgid(process.pid), signal.SIGTERM)
                time.sleep(2)
                try:
                    os.killpg(os.getpgid(process.pid), signal.SIGKILL)
                except:
                    pass
            except:
                pass
            sys.exit(1)
        
        # Wait and verify process is stable
        time.sleep(2)  # Initial wait
        
        if process.poll() is not None:
            # Process already exited
            exit_code = process.poll()
            log_message("Error: Application exited immediately with code {}".format(exit_code))
            # Read error output from file
            error_output = read_error_output()
            if error_output:
                log_message("Error output: {}".format(error_output))
            if os.path.exists(PID_FILE):
                try:
                    os.remove(PID_FILE)
                except:
                    pass
            sys.exit(1)
        
        # Verify process ownership
        verify_process_ownership(process.pid, java_cmd)
        
        # Verify process stays running for a period
        if not wait_for_process_stable(process.pid, max_checks=STABILITY_CHECKS, check_interval=STABILITY_INTERVAL):
            log_message("Error: Process did not remain stable")
            # Try to read error output
            error_output = read_error_output()
            if error_output:
                log_message("Error output: {}".format(error_output))
            if os.path.exists(PID_FILE):
                try:
                    os.remove(PID_FILE)
                except:
                    pass
            sys.exit(1)
        
        log_message("Application started successfully with PID {}".format(process.pid))
        
        # Run post-start hook
        run_hook(POST_START_HOOK, "post-start")
        
        log_message("=" * 60)
        log_message("Startup completed successfully")
        log_message("=" * 60)
        sys.exit(0)
        
    except subprocess.SubprocessError as e:
        log_message("Error starting process: {}".format(e))
        if process and process.poll() is None:
            try:
                os.killpg(os.getpgid(process.pid), signal.SIGTERM)
                time.sleep(2)
                try:
                    os.killpg(os.getpgid(process.pid), signal.SIGKILL)
                except:
                    pass
            except:
                pass
        if os.path.exists(PID_FILE):
            try:
                os.remove(PID_FILE)
            except:
                pass
        sys.exit(1)
    except Exception as e:
        log_message("Unexpected error: {}".format(e))
        import traceback
        log_message("Traceback: {}".format(traceback.format_exc()))
        if process and process.poll() is None:
            try:
                os.killpg(os.getpgid(process.pid), signal.SIGTERM)
                time.sleep(2)
                try:
                    os.killpg(os.getpgid(process.pid), signal.SIGKILL)
                except:
                    pass
            except:
                pass
        if os.path.exists(PID_FILE):
            try:
                os.remove(PID_FILE)
            except:
                pass
        sys.exit(1)
    finally:
        try:
            stdout_file.close()
            stderr_file.close()
        except:
            pass
        release_lock()

except SystemExit:
    release_lock()
    raise
except Exception as e:
    log_message("Fatal error: {}".format(e))
    import traceback
    log_message("Traceback: {}".format(traceback.format_exc()))
    release_lock()
    sys.exit(1)
